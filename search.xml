<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[夜雨]]></title>
      <url>%2F2016%2F12%2F21%2Fpoem4%E5%A4%9C%E9%9B%A8%2F</url>
      <content type="text"><![CDATA[香雨如酥贵如珠， 万家未觉身却无。 一心只为他人事， 浓绿艳妆为谁梳？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[夜行]]></title>
      <url>%2F2016%2F12%2F21%2Fpoem3%E5%A4%9C%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[桥接千断路， 夜连万重明。 灯火通明处， 醉是野鬼雄。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[踏春]]></title>
      <url>%2F2016%2F12%2F20%2Fpoem2%E8%B8%8F%E6%98%A5%2F</url>
      <content type="text"><![CDATA[柳絮无影叶有痕， 风捻末枝水上沉。 只作春泥润芳物， 不愿随水踏红尘。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春前]]></title>
      <url>%2F2016%2F12%2F19%2Fpoem1%E6%98%A5%E5%89%8D%2F</url>
      <content type="text"><![CDATA[轻风晓燕绕门前 朝霞初晖凝碧沿 沧海一粟人不定 落日飞花游子观]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(一)-函数封装--自定义-Log函数]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E4%B8%80)-%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85--%E8%87%AA%E5%AE%9A%E4%B9%89-Log%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617/** 自定义 Log 函数 - parameter log: log内容 - parameter file: log 函数所在的文件 - parameter method: log 函数所在的方法 - parameter lineNum: log 函数所在的行数 */func SLog&lt;T&gt;(log:T,file : String = #file , method :String = #function , lineNum : Int = #line) &#123; //Debug需要在 info.plist 文件配置,详见配图 #if Debug let fileName = ( file as NSString ).lastPathComponent print("[\(fileName) : \(method)] Line:\(lineNum) Log:\(log)" ) #endif&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十五)-好用的SwiftMessages的第三方库的封装]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81%E4%BA%94)-%E5%A5%BD%E7%94%A8%E7%9A%84SwiftMessages%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//// SwiftMessageManager.swift// showAlertMessage//// Created by 宋金委 on 16/8/30.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport SwiftMessages//布局样式enum LayoutType : String&#123; case MessageView case CardView case TabView case StatusLine case MessageViewIOS8&#125;//消息类型public enum ThemeType : String &#123; case Info case Success case Warning case Error&#125;class SwiftMessageManager: NSObject &#123; /** 生产 status 的抽取方法 - parameter layoutType: 布局样式 - parameter themeType: 消息类型 - parameter iconImageType: 消息图标的类型 - parameter presentationStyleType: 模态的位置 - parameter title: 标题 - parameter body: 说明文字 - parameter isHiddenBtn: 是否 隐藏 按钮 - parameter seconds: 显示的时间 */ class func showMessage(layoutType:LayoutType, themeType :ThemeType ,iconImageType : IconStyle, presentationStyleType :SwiftMessages.PresentationStyle, title :String,body:String, isHiddenBtn: Bool,seconds :NSTimeInterval) &#123; var view = MessageView.viewFromNib(layout: .MessageView) switch layoutType &#123; case .MessageView: print("已经在初始化的时候执行过") case .CardView: view = MessageView.viewFromNib(layout: .CardView) case .TabView: view = MessageView.viewFromNib(layout: .TabView) case .StatusLine: view = MessageView.viewFromNib(layout: .StatusLine) default: view = MessageView.viewFromNib(layout: .MessageViewIOS8) &#125; view.configureContent(title: title, body: body, iconImage: nil, iconText: nil, buttonImage: nil, buttonTitle: "隐藏", buttonTapHandler: &#123; _ in SwiftMessages.hide() &#125;) switch themeType &#123; case .Success: view.configureTheme(.Success, iconStyle:iconImageType) case .Warning: view.configureTheme(.Warning, iconStyle:iconImageType) case .Error: view.configureTheme(.Error, iconStyle:iconImageType) default: view.configureTheme(.Info, iconStyle:iconImageType) &#125; view.button?.hidden = isHiddenBtn; var infoConfig = SwiftMessages.Config() infoConfig.presentationStyle = presentationStyleType infoConfig.duration = .Seconds(seconds: seconds) SwiftMessages.show(config: infoConfig, view: view) &#125;&#125; 调用123456789101112131415161718192021222324252627282930313233343536373839404142434445//// ViewController.swift// showAlertMessage//// Created by HMC on 16/8/30.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport SwiftMessagesclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#125; @IBAction func clickBtn(sender: AnyObject) &#123; switch (sender as! UIButton).tag &#123; case 0: print("消息") SwiftMessageManager.showMessage(.MessageView, themeType:.Info, iconImageType:.Light, presentationStyleType:.Top, title: "信息", body: "我成功了", isHiddenBtn: true, seconds: 5) case 1: print("成功") SwiftMessageManager.showMessage(.MessageView, themeType:.Success, iconImageType:.Light, presentationStyleType:.Top, title: "信息", body: "我成功了", isHiddenBtn: false, seconds: 5) case 2: print("错误") SwiftMessageManager.showMessage(.MessageView, themeType:.Error, iconImageType:.Light, presentationStyleType:.Top, title: "信息", body: "我失败了", isHiddenBtn: true, seconds: 5) case 3: print("警告") SwiftMessageManager.showMessage(.MessageView, themeType:.Warning, iconImageType:.Light, presentationStyleType:.Top, title: "信息", body: "我成功了", isHiddenBtn: true, seconds: 1) default: print("自定义") &#125; &#125; &#125; 代码在这 点我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(五)-按钮点击,新调用的形式]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E4%BA%94)-%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%2C%E6%96%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%BD%A2%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324//// ViewController.swift// SwiftTest2//// Created by HMC on 16/8/8.// Copyright © 2016年 SKing. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var btn: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() createVCObjectFromString("SViewController") //#selector(click) 新形式调用点击方法 btn.addTarget(self, action:#selector(click), forControlEvents: .TouchUpInside) &#125; @objc private func click()&#123; print("123132") &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(六)-convenience-构造函数]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%85%AD)-convenience-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[创建 swift 文件,命名规则见名知义123456789101112131415161718//// Button-Ext.swift// SwiftTest2//// Created by HMC on 16/8/9.// Copyright © 2016年 SKing. All rights reserved.//import Foundationimport UIKitextension UIButton &#123; convenience init(name: String) &#123; self.init() print(name) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十)-Bezier-曲线-实现下载图片进度绘制]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81)-Bezier-%E6%9B%B2%E7%BA%BF-%E5%AE%9E%E7%8E%B0%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E8%BF%9B%E5%BA%A6%E7%BB%98%E5%88%B6%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142//// progressView.swift// swift-AFNetworking//// Created by HMC on 16/8/11.// Copyright © 2016年 SKing. All rights reserved.//import UIKitclass progressView: UIView &#123; var progress : CGFloat = 0.0 &#123; //属性改变监听 didSet &#123; print("改变了") setNeedsDisplay() &#125; &#125; override func drawRect(rect: CGRect) &#123; super.drawRect(rect) backgroundColor = UIColor.clearColor() let arcCenter = CGPoint(x: rect.width * 0.5, y: rect.height * 0.5) let radius = rect.width * 0.5 - 3 let startAngle = CGFloat(-M_PI_2) let endAngle = CGFloat(M_PI * 2) * progress + startAngle let bezierPath = UIBezierPath(arcCenter: arcCenter, radius: radius, startAngle: startAngle, endAngle: endAngle, clockwise: true) bezierPath.addLineToPoint(arcCenter) bezierPath.closePath() UIColor(white: 1.0, alpha: 0.8).setFill() bezierPath.fill() &#125;&#125; 控件的设置,调用方法如下,点击加载按钮 下载图片显示进度.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// ViewController.swift// swift-AFNetworking//// Created by HMC on 16/8/9.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport HYLabelimport SDWebImageclass ViewController: UIViewController &#123; @IBAction func GoToAuth(sender: AnyObject) &#123; let authNav = UINavigationController(rootViewController: AuthViewController()) presentViewController(authNav, animated: true, completion: nil) &#125; @IBOutlet weak var imageView: UIImageView! @IBAction func loadView(sender: AnyObject) &#123; imageView.sd_setImageWithURL(NSURL(string:"http://httpbin.org/image/jpeg"), placeholderImage: nil, options: [], progress: &#123; (current, total) in self.progress.hidden = false self.progress.progress = CGFloat(current) / CGFloat(total) &#125;) &#123; (_, _, _, _) in self.progress.hidden = true &#125; SDImageCache.sharedImageCache().clearDisk() &#125; //懒加载 lazy var progress : progressView = progressView() override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = UIColor.greenColor() view.addSubview(progress) progress.bounds = CGRect(x: 0, y: 0, width: 50, height: 50) progress.center = CGPoint(x: SCREENWIDTH * 0.5, y: SCREENHEIGHT * 0.5) progress.hidden = true &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十一)-QRScanner-二维码生成、识别、扫描]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81%E4%B8%80)-QRScanner-%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E3%80%81%E8%AF%86%E5%88%AB%E3%80%81%E6%89%AB%E6%8F%8F%2F</url>
      <content type="text"><![CDATA[#一 、生成二维码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//// showQRController.swift// QRCode//// Created by HMC on 16/8/11.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport CoreImageclass showQRController: UIViewController &#123; @IBOutlet weak var QRImageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() QRImageView.image = createQR("香雨如酥贵如珠， 万家未觉身却无。 一心只为他人事， 浓绿艳妆为谁梳？", iconImageName: "123") &#125;&#125;extension showQRController &#123; func createQR(string : String?,iconImageName: String?) -&gt; UIImage? &#123; //创建二维码滤镜 固定格式 参数必须为 : CIQRCodeGenerator let filter = CIFilter(name: "CIQRCodeGenerator") //复位滤镜,以便下次使用 filter?.setDefaults() //KVC 设置输入值 ps:key 固定为inputMessage ,value 必须为 nsdata 类型 guard string != nil else &#123; return nil &#125; let inputData = string!.dataUsingEncoding(NSUTF8StringEncoding) filter?.setValue(inputData, forKey: "inputMessage") //设置纠错率 一般设置为M filter?.setValue("M", forKey: "inputCorrectionLevel") //接收滤镜返回的图片,由于太小 需要拉伸放大 guard let image = filter?.outputImage else &#123; return nil &#125; //颜色滤镜 let colorFilter = CIFilter(name: "CIFalseColor") colorFilter?.setDefaults() colorFilter?.setValue(image, forKey: "inputImage") //前景色 colorFilter?.setValue(CIColor(red: 225/255.0, green: 77/255.0,blue: 0), forKey: "inputColor0") //背景色 colorFilter?.setValue(CIColor(red: 1, green: 1,blue: 1), forKey: "inputColor1") guard let colorImage = colorFilter?.outputImage else&#123; return nil &#125; //放大25倍 重绘 let matrix = CGAffineTransformMakeScale(25, 25) //将 CIImage 转换为 UIImage let QRImage = UIImage(CIImage:colorImage.imageByApplyingTransform(matrix)) //判定 icon 是否为空 guard iconImageName != nil else &#123; return nil &#125; //重新绘制中心小图 if let iconImage = UIImage(named: iconImageName!) &#123; let rect = CGRectMake(0, 0, QRImage.size.width, QRImage.size.height) UIGraphicsBeginImageContext(rect.size) QRImage.drawInRect(rect) let iconSize = CGSizeMake(rect.size.width * 0.25, rect.size.height * 0.25) let x = (rect.width - iconSize.width ) * 0.5 let y = (rect.height - iconSize.height ) * 0.5 iconImage.drawInRect(CGRectMake(x,y,iconSize.width,iconSize.height)) let resultImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return resultImage &#125; return QRImage &#125; &#125; #二 、识别二维码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// detectorViewController.swift// QRCode//// Created by HMC on 16/8/12.// Copyright © 2016年 SKing. All rights reserved.//import UIKitclass detectorViewController: UIViewController &#123; @IBOutlet weak var imageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // 获得 image guard let image = imageView.image else&#123; return &#125; //转换为 CIImage let ciImage = CIImage(image: image) //创建探测器 let detector = CIDetector(ofType: CIDetectorTypeQRCode, context: nil, options: [CIDetectorAccuracy : CIDetectorAccuracyHigh]) //返回结果 let features = detector.featuresInImage(ciImage!) //遍历结果 for feature in features &#123; let qrcode = feature as! CIQRCodeFeature print(qrcode.messageString) //alert 显示识别出的内容 let alert = UIAlertController(title: "识别内容", message:qrcode.messageString, preferredStyle: .Alert) let action = UIAlertAction(title: "关闭", style: .Default, handler: &#123; (action : UIAlertAction) in self.dismissViewControllerAnimated(true, completion: nil) &#125;) alert.addAction(action) presentViewController(alert, animated: true, completion: nil) &#125; &#125;&#125; #三 、扫描二维码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161//// scanQRViewController.swift// QRCode//// Created by HMC on 16/8/15.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport AVFoundationclass scanQRViewController: UIViewController &#123; lazy var session = AVCaptureSession() /// 扫描网格 距离 框的底部的长度 @IBOutlet weak var lineToBottom: NSLayoutConstraint! /// 扫描框和扫描线的背景 View @IBOutlet weak var scanBackground: UIView! //扫描框 @IBOutlet weak var scanDeadLine: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. startScan() &#125; override func viewDidAppear(animated: Bool) &#123; super.viewDidAppear(animated) startAnimationOfLine() &#125; &#125;// MARK: - 有关的 UI 和动画extension scanQRViewController&#123; /** 开始扫描 */ func startScan()&#123; //获取摄像头 let hardWareDevice = AVCaptureDevice.defaultDeviceWithMediaType(AVMediaTypeVideo) //输入 guard let input = try? AVCaptureDeviceInput(device: hardWareDevice) else&#123; return &#125; //输出 let output = AVCaptureMetadataOutput() //设置输出的代理 output.setMetadataObjectsDelegate(self, queue: dispatch_get_main_queue()) //连接输入输出 //session = AVCaptureSession() guard session.canAddInput(input) else&#123; return &#125; guard session.canAddOutput(output) else &#123; return &#125; session.addInput(input) session.addOutput(output) //输出的二维码识别的码制(所有的码) output.metadataObjectTypes = output.availableMetadataObjectTypes //设置扫描的区域 0.0-1.0// let screenBounds = UIScreen.mainScreen().bounds// let x :CGFloat = scanBackground.frame.origin.x / screenBounds.size.width// let y :CGFloat = scanBackground.frame.origin.y / screenBounds.size.height// let width :CGFloat = scanBackground.frame.size.width / screenBounds.size.width// let height :CGFloat = scanBackground.frame.size.height / screenBounds.size.height// output.rectOfInterest = CGRectMake(y, x, height, width) //添加摄像头图层 (其实不是必须的) let captureLayer = AVCaptureVideoPreviewLayer(session: session) captureLayer.frame = view.layer.bounds view.layer.insertSublayer(captureLayer, atIndex: 0) // 启动回话: 此时开始采集数据,输出对象 session.startRunning() &#125; /** 动画的设置 */ func startAnimationOfLine() &#123; //初始化线的位置 lineToBottom.constant = scanBackground.frame.height loadViewIfNeeded() //设置结束位置 lineToBottom.constant = -scanBackground.frame.height //设置动画 UIView.animateWithDuration(3, animations: &#123; //设置重复 UIView.setAnimationRepeatCount(MAXFLOAT) self.view.layoutIfNeeded() &#125;) &#123; (bool : Bool) in print("回扫") &#125; &#125; &#125;// MARK: - AVCaptureMetadataOutputObjectsDelegateextension scanQRViewController : AVCaptureMetadataOutputObjectsDelegate &#123; func captureOutput(captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [AnyObject]!, fromConnection connection: AVCaptureConnection!) &#123; guard metadataObjects.count &gt; 0 else&#123; return &#125; for obj in metadataObjects &#123; guard obj.isKindOfClass(AVMetadataMachineReadableCodeObject) else&#123; return &#125; let tmpObj = obj as! AVMetadataMachineReadableCodeObject //print(tmpObj.stringValue) //print(tmpObj.corners) let alert = UIAlertController(title: "识别结果", message: tmpObj.stringValue, preferredStyle: .Alert) let action = UIAlertAction(title: "好", style: .Default, handler: &#123; (action: UIAlertAction) in self.dismissViewControllerAnimated(true, completion: nil) &#125;) alert.addAction(action) presentViewController(alert, animated: true, completion: nil) &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(七)-封装-AFNetworking3-1(未完成)]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E4%B8%83)-%E5%B0%81%E8%A3%85-AFNetworking3-1(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//// AFNetworkingManager.swift// swift-AFNetworking//// Created by HMC on 16/8/9.// Copyright © 2016年 SKing. All rights reserved.//import AFNetworking//自定义枚举类型enum RequestType &#123; case GET //get请求 case POST //post请求 case DOWNLOAD //下载请求 case UPLOAD //上传请求&#125;class AFNetworkingManager: AFHTTPSessionManager &#123; //单例模式 使用闭包对实例进行值设定 static let shareObject : AFNetworkingManager = &#123; let manager = AFNetworkingManager() //对于 set 对象可以进行 insert 方法进行设定值 manager.responseSerializer.acceptableContentTypes? = ["text/html","text/plain","application/json"] return manager &#125;() &#125;extension AFNetworkingManager &#123; /** 请求数据函数 - parameter requestType: 请求类型 - parameter urlString: 请求 url - parameter parameters: 请求字典参数 - parameter returnData: 请求返回的闭包 用于数据回调 */ func requestData(requestType: RequestType , urlString :String , parameters :[String : AnyObject]?,returnData : (result : AnyObject?,error : NSError?)-&gt;()) &#123; //去除 URL 中的ASSIC 码 let urlString = urlString.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())! print(urlString) //请求成功闭包 let success = &#123; (task : NSURLSessionDataTask,result : AnyObject?) in print(result) returnData(result: result,error: nil) &#125; //请求失败闭包 let failure = &#123; (task : NSURLSessionDataTask?,error : NSError) in print(error) returnData(result: nil, error: error) &#125; if requestType == .GET &#123;//get 类型请求 GET(urlString, parameters: parameters,progress : nil, success: success , failure: failure) &#125; else if requestType == .POST&#123;//post 类型请求 POST(urlString, parameters: parameters, progress: nil, success: success, failure: failure) &#125; else if requestType == .DOWNLOAD &#123;//下载 类型请求 &#125; else if requestType == .UPLOAD &#123;//上传 类型请求 &#125; &#125; &#125; 调用例子 AFNetworkingManager.shareObject.requestData()12345678//get 请求AFNetworkingManager.shareObject.requestData(.GET, urlString: &quot;http://httpbin.org/get&quot;, parameters: [&quot;name&quot; : &quot;SongJinwei&quot;,&quot;age&quot; : 25]) &#123; (result, error) in print(result) &#125;//post 请求AFNetworkingManager.shareObject.requestData(.POST, urlString: &quot;http://httpbin.org/post&quot;, parameters: [&quot;name&quot; : &quot;SongJinwei&quot;,&quot;age&quot; : 25]) &#123; (result, error) in print(result) &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十三)-Cocoapod---Podfile内容]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81%E4%B8%89)-Cocoapod---Podfile%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627# Uncomment this line to define a global platform for your projectplatform :ios, '9.0' target '工程名字' do # Comment this line if you're not using Swift and don't want to use dynamic frameworks use_frameworks! # Pods for swift-AFNetworking target '工程名字Tests' do inherit! :search_paths # Pods for testing end target '工程名字UITests' do inherit! :search_paths # Pods for testing endpod 'AFNetworking'pod 'SDWebImage'#自动布局pod 'SnapKit'pod 'SVProgressHUD'end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十二)-QRScanner-二维码封装总结]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81%E4%BA%8C)-QRScanner-%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B0%81%E8%A3%85%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[#封装类 SQRCode.swift123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250//// SQRCode.swift 封装集成类// QRCode//// Created by HMC on 16/8/16.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport AVFoundation//闭包的别名typealias result = (String)-&gt;()class SQRCode: NSObject &#123; //懒加载 闭包 lazy var input : AVCaptureInput? = &#123; //获取摄像头 let hardWareDevice = AVCaptureDevice.defaultDeviceWithMediaType(AVMediaTypeVideo) //输入 guard let input = try? AVCaptureDeviceInput(device: hardWareDevice) else&#123; return nil &#125; return input &#125;() lazy var output : AVCaptureMetadataOutput? = &#123; //输出 let output = AVCaptureMetadataOutput() //设置输出的代理 output.setMetadataObjectsDelegate(self, queue: dispatch_get_main_queue()) return output &#125;() lazy var captureLayer : AVCaptureVideoPreviewLayer = &#123; let captureLayer = AVCaptureVideoPreviewLayer(session: self.session) return captureLayer &#125;() lazy var session : AVCaptureSession = &#123; let session = AVCaptureSession() return session &#125;() //结果闭包 private var resultClosures : result? //单例 static let sharedObject = SQRCode() /** 实例方法:扫描二维码 - parameter view: 在哪个 VC 的 View - parameter result: 闭包输出结果 便于回传到对应的 VC 上 */ func scanQRCode(view:UIView , result:(String)-&gt;()) &#123; // resultClosures = result //连接输入输出 if session.canAddInput(input) &amp;&amp; session.canAddOutput(output) &#123; session.addInput(input) session.addOutput(output) &#125; //输出的二维码识别的码制(所有的码) output!.metadataObjectTypes = output!.availableMetadataObjectTypes //设置扫描的区域 0.0-1.0 // let screenBounds = UIScreen.mainScreen().bounds // let x :CGFloat = scanBackground.frame.origin.x / screenBounds.size.width // let y :CGFloat = scanBackground.frame.origin.y / screenBounds.size.height // let width :CGFloat = scanBackground.frame.size.width / screenBounds.size.width // let height :CGFloat = scanBackground.frame.size.height / screenBounds.size.height // output.rectOfInterest = CGRectMake(y, x, height, width) //添加摄像头图层 (其实不是必须的) 防止重复 let sublayers = view.layer.sublayers! guard !sublayers.contains(captureLayer) else &#123; return &#125; captureLayer.frame = view.layer.bounds view.layer.insertSublayer(captureLayer, atIndex: 0) // 启动回话: 此时开始采集数据,输出对象 session.startRunning() &#125; /** 类方法:生成二维码 - parameter string: 字符串 - parameter iconImageName: 中心的 Icon - returns: 生成的二维码 */ class func createQR(string : String?,iconImageName: String?) -&gt; UIImage? &#123; //创建二维码滤镜 固定格式 参数必须为 : CIQRCodeGenerator let filter = CIFilter(name: "CIQRCodeGenerator") //复位滤镜,以便下次使用 filter?.setDefaults() //KVC 设置输入值 ps:key 固定为inputMessage ,value 必须为 nsdata 类型 guard string != nil else &#123; return nil &#125; let inputData = string!.dataUsingEncoding(NSUTF8StringEncoding) filter?.setValue(inputData, forKey: "inputMessage") //设置纠错率 一般设置为M filter?.setValue("M", forKey: "inputCorrectionLevel") //接收滤镜返回的图片,由于太小 需要拉伸放大 guard let image = filter?.outputImage else &#123; return nil &#125; //颜色滤镜 let colorFilter = CIFilter(name: "CIFalseColor") colorFilter?.setDefaults() colorFilter?.setValue(image, forKey: "inputImage") //前景色 colorFilter?.setValue(CIColor(red: 225/255.0, green: 77/255.0,blue: 0), forKey: "inputColor0") //背景色 colorFilter?.setValue(CIColor(red: 1, green: 1,blue: 1), forKey: "inputColor1") guard let colorImage = colorFilter?.outputImage else&#123; return nil &#125; //放大25倍 重绘 let matrix = CGAffineTransformMakeScale(25, 25) //将 CIImage 转换为 UIImage let QRImage = UIImage(CIImage:colorImage.imageByApplyingTransform(matrix)) //判定 icon 是否为空 guard iconImageName != nil else &#123; return nil &#125; //重新绘制中心小图 if let iconImage = UIImage(named: iconImageName!) &#123; let rect = CGRectMake(0, 0, QRImage.size.width, QRImage.size.height) UIGraphicsBeginImageContext(rect.size) QRImage.drawInRect(rect) let iconSize = CGSizeMake(rect.size.width * 0.25, rect.size.height * 0.25) let x = (rect.width - iconSize.width ) * 0.5 let y = (rect.height - iconSize.height ) * 0.5 iconImage.drawInRect(CGRectMake(x,y,iconSize.width,iconSize.height)) let resultImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return resultImage &#125; return QRImage &#125; /** 类方法:识别二维码 - parameter image: 被识别的图片 - returns: 返回识别的结果 */ class func detectorQRFromImage(image:UIImage) -&gt; (String?) &#123; //转换为 CIImage let ciImage = CIImage(image: image) //创建探测器 let detector = CIDetector(ofType: CIDetectorTypeQRCode, context: nil, options: [CIDetectorAccuracy : CIDetectorAccuracyHigh]) //返回结果 let features = detector.featuresInImage(ciImage!) //遍历结果 for feature in features &#123; let qrcode = feature as! CIQRCodeFeature //print(qrcode.messageString) return qrcode.messageString &#125; return nil &#125;&#125;// MARK: - AVCaptureMetadataOutputObjectsDelegateextension SQRCode : AVCaptureMetadataOutputObjectsDelegate &#123; func captureOutput(captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [AnyObject]!, fromConnection connection: AVCaptureConnection!) &#123; guard metadataObjects.count &gt; 0 else&#123; return &#125; var resultStr : String? for obj in metadataObjects &#123; guard obj.isKindOfClass(AVMetadataMachineReadableCodeObject) else&#123; return &#125; let tmpObj = obj as! AVMetadataMachineReadableCodeObject print(tmpObj.stringValue) //print(tmpObj.corners) resultStr = tmpObj.stringValue &#125; guard (resultClosures != nil) else&#123; return &#125; guard resultStr != nil else&#123; return &#125; resultClosures!(resultStr!) &#125;&#125; #调用的例子: ##例一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// scanQRViewController.swift// QRCode//// Created by HMC on 16/8/15.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport AVFoundationclass scanQRViewController: UIViewController &#123; //lazy var session = AVCaptureSession() /// 扫描网格 距离 框的底部的长度 @IBOutlet weak var lineToBottom: NSLayoutConstraint! /// 扫描框和扫描线的背景 View @IBOutlet weak var scanBackground: UIView! //扫描框 @IBOutlet weak var scanDeadLine: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. // startScan() SQRCode.sharedObject.scanQRCode(view) &#123; (result:String) in let alert = UIAlertController(title: "识别结果", message: result, preferredStyle: .Alert) let action = UIAlertAction(title: "好", style: .Default, handler: &#123; (action: UIAlertAction) in self.dismissViewControllerAnimated(true, completion: nil) &#125;) alert.addAction(action) self.presentViewController(alert, animated: true, completion: nil) &#125; &#125; override func viewDidAppear(animated: Bool) &#123; super.viewDidAppear(animated) startAnimationOfLine() &#125; &#125;// MARK: - 有关的 UI 和动画extension scanQRViewController&#123; /** 动画的设置 */ func startAnimationOfLine() &#123; //初始化线的位置 lineToBottom.constant = scanBackground.frame.height loadViewIfNeeded() //设置结束位置 lineToBottom.constant = -scanBackground.frame.height //设置动画 UIView.animateWithDuration(3, animations: &#123; //设置重复 UIView.setAnimationRepeatCount(MAXFLOAT) self.view.layoutIfNeeded() &#125;) &#123; (bool : Bool) in print("回扫") &#125; &#125; &#125; ##例二1234567891011121314151617181920212223//// showQRController.swift// QRCode//// Created by HMC on 16/8/11.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport CoreImageclass showQRController: UIViewController &#123; @IBOutlet weak var QRImageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() QRImageView.image = SQRCode.createQR("香雨如酥贵如珠， 万家未觉身却无。 一心只为他人事， 浓绿艳妆为谁梳？", iconImageName: "123") &#125;&#125; ##例三12345678910111213141516171819202122232425262728293031323334353637383940//// detectorViewController.swift// QRCode//// Created by HMC on 16/8/12.// Copyright © 2016年 SKing. All rights reserved.//import UIKitclass detectorViewController: UIViewController &#123; @IBOutlet weak var imageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // 获得 image guard let image = imageView.image else&#123; return &#125; let returnStr = SQRCode.detectorQRFromImage(image) //alert 显示识别出的内容 let alert = UIAlertController(title: "识别内容", message:returnStr, preferredStyle: .Alert) let action = UIAlertAction(title: "关闭", style: .Default, handler: &#123; (action : UIAlertAction) in self.dismissViewControllerAnimated(true, completion: nil) &#125;) alert.addAction(action) presentViewController(alert, animated: true, completion: nil) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(八)-完成Sina授权,获取accessToken]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%85%AB)-%E5%AE%8C%E6%88%90Sina%E6%8E%88%E6%9D%83%2C%E8%8E%B7%E5%8F%96accessToken%2F</url>
      <content type="text"><![CDATA[公共文件定义 Sina 的分发的 key12345678910111213//// Global.swift// swift-AFNetworking//// Created by HMC on 16/8/10.// Copyright © 2016年 SKing. All rights reserved.//import Foundationlet AppKey = "2*********"let AppSecret = "d*******"let redirect_uri = "http://www.jianshu.com" 授权页加载,所用的网络请求已经在上一篇笔记中完成,不懂请查看.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//// AuthViewController.swift// swift-AFNetworking//// Created by HMC on 16/8/10.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport SVProgressHUDclass AuthViewController: UIViewController &#123; @IBOutlet weak var webV: UIWebView! override func viewDidLoad() &#123; super.viewDidLoad() //设置 navigationController setNav() //加载 webview 的授权 authorToSina(AppKey, appURL: redirect_uri) &#125;&#125;// MARK: - 控制器NavigationController的设置extension AuthViewController &#123; private func setNav()&#123; navigationItem.leftBarButtonItem = UIBarButtonItem(title: "返回", style: .Plain, target: self, action: #selector(back)) navigationItem.rightBarButtonItem = UIBarButtonItem(title: "自动登录", style: .Plain, target: self, action: #selector(autoLogin)) &#125; //返回 func back() &#123; dismissViewControllerAnimated(true, completion: nil) &#125; //自动登录 func autoLogin() &#123; //思路:注入 js 代码到 webView let jsString = "document.getElementById('userId').value='15225124020';document.getElementById('passwd').value='自己账户的密码';" webV.stringByEvaluatingJavaScriptFromString(jsString) &#125; func authorToSina(appkey:String,appURL:String) &#123; webV.loadRequest(NSURLRequest(URL: NSURL(string: "https://api.weibo.com/oauth2/authorize?client_id=\(appkey)&amp;redirect_uri=\(appURL)")!)) &#125;&#125;//MARK:- webView 代理extension AuthViewController: UIWebViewDelegate&#123; func webViewDidStartLoad(webView: UIWebView) &#123; SVProgressHUD.show() &#125; func webViewDidFinishLoad(webView: UIWebView) &#123; SVProgressHUD.dismiss() &#125; func webView(webView: UIWebView, didFailLoadWithError error: NSError?) &#123; SVProgressHUD.dismiss() &#125; // func webView(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool &#123; guard let url = request.URL else &#123; return true &#125; guard url.absoluteString.containsString("code=")else &#123; return true &#125; let separateArray = url.absoluteString.componentsSeparatedByString("code=") //获取 code let code = separateArray.last getAccessToken(code!) print(code) return false &#125; &#125;// MARK: - 用sina 返回的 code 获取 accessTokenextension AuthViewController &#123; private func getAccessToken(code : String) &#123; let staticURL = "https://api.weibo.com/oauth2/access_token" //"grant_type":"authorization_code" 固定写法 let parameters = ["client_id":AppKey, "client_secret":AppSecret, "grant_type":"authorization_code", "redirect_uri":redirect_uri, "code":code] AFNetworkingManager.shareObject.requestData(.POST, urlString: staticURL, parameters: parameters) &#123; (result, error) in print(result) &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十六)-系统的服务调用(振动,声音)]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81%E5%85%AD)-%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8(%E6%8C%AF%E5%8A%A8%2C%E5%A3%B0%E9%9F%B3)%2F</url>
      <content type="text"><![CDATA[这个功能无法截图将就着看吧,多谅解;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// ViewController.swift// systemDevice//// Created by HMC on 2016/10/20.// Copyright © 2016年 HMC. All rights reserved.//import UIKitimport AudioToolboxclass ViewController: UIViewController &#123; var sysID:SystemSoundID = 0 /** 振动 - parameter sender: sender description */ @IBAction func shake(sender: AnyObject) &#123; AudioServicesPlaySystemSound(kSystemSoundID_Vibrate) &#125; /** 响铃 - parameter sender: sender description */ @IBAction func ring(sender: AnyObject) &#123; AudioServicesPlayAlertSound(sysID) &#125; override func viewDidLoad() &#123; super.viewDidLoad() //预先加载 let path = NSBundle.mainBundle().pathForResource("ring", ofType: "wav") AudioServicesCreateSystemSoundID(NSURL(fileURLWithPath: path!), &amp;sysID) &#125; deinit&#123; //注意释放 service AudioServicesDisposeSystemSoundID(sysID) &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十四)-通讯录-AddressBook-封装]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81%E5%9B%9B)-%E9%80%9A%E8%AE%AF%E5%BD%95-AddressBook-%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258//// AddressBookManager.swift// AddressBook//// Created by HMC on 16/8/19.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport ContactsUI//定义生日的结构体struct birth &#123; var year = 1900 var month = 1 var day = 1 &#125;//定义地址的结构体struct personalAddress &#123; var street = "朝阳三里屯" var city = "北京" var country = "中国" var postalCode = "100000" &#125;class AddressBookManager: NSObject &#123; var delegate:CNContactPickerDelegate! &#125;extension AddressBookManager &#123; /** 添加新的通信录到 addressbook - parameter familyName: 姓 - parameter givenName: 名(必填) - parameter imageName: 头像 - parameter homeMail: 个人邮箱 - parameter workMail: 工作邮箱 - parameter phoneNumber: 手机号(必填) - parameter bir: 生日(结构体) - parameter postalAddress: 地址 */ func addContact(familyName : String? ,givenName : String ,imageName : String? ,homeMail : String? ,workMail : String? ,phoneNumber : String ,bir : birth? ,postalAddress : personalAddress? ) &#123; let contactStore = CNContactStore() contactStore.requestAccessForEntityType(.Contacts) &#123; (granted : Bool, error : NSError?) in if granted &#123; print("授权成功") //创建联系人对象 let aPeople = CNMutableContact() if (familyName != nil) &#123; //姓 aPeople.familyName = familyName! &#125; //名 aPeople.givenName = givenName if (imageName != nil) &#123; //头像 aPeople.imageData = UIImagePNGRepresentation( UIImage(named: imageName!)!) &#125; /* CONTACTS_EXTERN NSString * const CNLabelHome 家庭 CONTACTS_EXTERN NSString * const CNLabelWork 工作 CONTACTS_EXTERN NSString * const CNLabelOther 其他 CONTACTS_EXTERN NSString * const CNLabelEmailiCloud 邮箱地址 CONTACTS_EXTERN NSString * const CNLabelURLAddressHomePage url地址 CONTACTS_EXTERN NSString * const CNLabelDateAnniversary 日期 */ var addressArray : [CNLabeledValue] = [] if (homeMail != nil) &#123; //私人邮箱 let homeMail = CNLabeledValue.init(label: CNLabelHome, value: homeMail!) addressArray.append(homeMail) &#125; if (workMail != nil) &#123; //工作邮箱 let workMail = CNLabeledValue.init(label: CNLabelWork, value: workMail!) addressArray.append(workMail) &#125; //设置邮箱 aPeople.emailAddresses = addressArray /* CONTACTS_EXTERN NSString * const CNLabelPhoneNumberiPhone CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMobile CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMain CONTACTS_EXTERN NSString * const CNLabelPhoneNumberHomeFax CONTACTS_EXTERN NSString * const CNLabelPhoneNumberWorkFax CONTACTS_EXTERN NSString * const CNLabelPhoneNumberOtherFax CONTACTS_EXTERN NSString * const CNLabelPhoneNumberPager */ //电话 let phoneNumber = CNLabeledValue.init(label: CNLabelPhoneNumberiPhone, value: CNPhoneNumber(stringValue: phoneNumber)) aPeople.phoneNumbers = [phoneNumber] if (bir != nil) &#123; //生日 let birthday = NSDateComponents() birthday.day = bir!.day birthday.month = bir!.month birthday.year = bir!.year aPeople.birthday = birthday &#125; if (postalAddress != nil) &#123; //地址 let pAddress = CNMutablePostalAddress() pAddress.street = postalAddress!.street pAddress.city = postalAddress!.city pAddress.country = postalAddress!.country //邮编 pAddress.postalCode = postalAddress!.postalCode aPeople.postalAddresses = [CNLabeledValue.init(label: CNLabelHome, value: pAddress)] &#125; //请求添加联系人 let saveRequest = CNSaveRequest() saveRequest.addContact(aPeople, toContainerWithIdentifier: nil) /* //更新一个联系人 - (void)updateContact:(CNMutableContact *)contact; //删除一个联系人 - (void)deleteContact:(CNMutableContact *)contact; //添加一组联系人 - (void)addGroup:(CNMutableGroup *)group toContainerWithIdentifier:(nullable NSString *)identifier; //更新一组联系人 - (void)updateGroup:(CNMutableGroup *)group; //删除一组联系人 - (void)deleteGroup:(CNMutableGroup *)group; //向组中添加子组 - (void)addSubgroup:(CNGroup *)subgroup toGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA); //在组中删除子组 - (void)removeSubgroup:(CNGroup *)subgroup fromGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA); //向组中添加成员 - (void)addMember:(CNContact *)contact toGroup:(CNGroup *)group; //向组中移除成员 - (void)removeMember:(CNContact *)contact fromGroup:(CNGroup *)group; */ //写入通信录 guard ((try? contactStore.executeSaveRequest(saveRequest)) != nil) else &#123; print("添加失败") return &#125; &#125;else&#123; print("授权失败") &#125; &#125; &#125; /** 查找通信录的指定字段 - parameter strArray: 参数字段 CNContactNamePrefixKey CNContactGivenNameKey CNContactMiddleNameKey CNContactFamilyNameKey CNContactPreviousFamilyNameKey CNContactNameSuffixKey CNContactNicknameKey CNContactPhoneticGivenNameKey CNContactPhoneticMiddleNameKey CNContactPhoneticFamilyNameKey CNContactOrganizationNameKey CNContactDepartmentNameKey CNContactJobTitleKey CNContactBirthdayKey CNContactNonGregorianBirthdayKey CNContactNoteKey CNContactImageDataKey CNContactThumbnailImageDataKey CNContactImageDataAvailableKey CNContactTypeKey CNContactPhoneNumbersKey CNContactEmailAddressesKey CNContactPostalAddressesKey CNContactDatesKey CNContactUrlAddressesKey CNContactRelationsKey CNContactSocialProfilesKey CNContactInstantMessageAddressesKey */ func searchContact(strArray:[CNKeyDescriptor],completionHandler: (result: [[String : String]]) -&gt; Void) -&gt; Void&#123; var result = [[String : String]]() let contactStore = CNContactStore() contactStore.requestAccessForEntityType(.Contacts) &#123;(granted : Bool, error : NSError?) in if granted &#123; let request = CNContactFetchRequest(keysToFetch: strArray) guard ((try? contactStore.enumerateContactsWithFetchRequest(request, usingBlock: &#123; (contact:CNContact,stop) in let numbers = contact.phoneNumbers for number in numbers&#123; let phoneNum = number.value as! CNPhoneNumber //print(contact.familyName,phoneNum.stringValue) let tmpDict = ["name":contact.familyName,"phoneNum":phoneNum.stringValue] result.append(tmpDict) &#125; &#125;)) != nil) else &#123; return &#125; completionHandler(result: result) &#125;else&#123; print("授权失败") return &#125; &#125; &#125;&#125;// MARK: - CNContactPickerDelegateextension AddressBookManager : CNContactPickerDelegate &#123; func contactPickerDidCancel(picker: CNContactPickerViewController) &#123; print("Cancel") &#125; func contactPicker(picker: CNContactPickerViewController, didSelectContact contact: CNContact) &#123; let formatterName = CNContactFormatter.stringFromContact(contact, style: .FullName) print(formatterName) &#125; &#125; #调用12345678910111213141516171819202122232425262728293031//// ViewController.swift// AddressBook//// Created by HMC on 16/8/19.// Copyright © 2016年 SKing. All rights reserved.//import UIKitimport ContactsUIclass ViewController: UIViewController &#123; lazy var addressBook = CNContactPickerViewController() lazy var ad = AddressBookManager() override func viewDidLoad() &#123; super.viewDidLoad() addressBook.delegate = ad ad.addContact("songjinwei", givenName: "jw", imageName: nil, homeMail: nil, workMail: nil, phoneNumber: "15225124020", bir: nil, postalAddress: nil) ad.searchContact([CNContactFamilyNameKey,CNContactGivenNameKey,CNContactPhoneNumbersKey]) &#123; (result) in print(result) &#125; presentViewController(addressBook, animated: true, completion: nil) &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(四)--异常处理--try]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%9B%9B)--%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86--try%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132//// ViewController.swift// Swift_try//// Created by HMC on 16/8/8.// Copyright © 2016年 SKing. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() /*提供三种处理异常的方式 ①try 方式 手动处理 ②try? 方式 自动处理(常用) 如果有返回 nil 如果没有直接返回相应的对象 guard let name = try? 方法 else &#123; return &#125; ③try! 方式 告诉系统改方法无异常 如果出现直接 trash(不建议) */ //正则表达式 //创建正则的规则 let pattern = "sjw" //创建正则表达式的对象 guard let regex = try? NSRegularExpression(pattern: pattern, options: .CaseInsensitive) else &#123; return &#125; print(regex) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(二)--函数封装--根据字符串创建对应的对象简单使用 tableview]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E4%BA%8C)--%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8-tableView%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// ViewController.swift// swiftTableView//// Created by 宋金委 on 16/8/7.// Copyright © 2016年 song. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; lazy var tableVIew = UITableView() override func viewDidLoad() &#123; super.viewDidLoad() tableVIew.frame = view.bounds view.addSubview(tableVIew) tableVIew.dataSource = self tableVIew.delegate = self &#125;&#125;// MARK: - UITableViewDataSource,UITableViewDelegateextension ViewController :UITableViewDataSource,UITableViewDelegate &#123; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 10; &#125; func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cellID = "cellID" var cell = tableView.dequeueReusableCellWithIdentifier(cellID) if cell == nil &#123; cell = UITableViewCell(style: .Default, reuseIdentifier: cellID) &#125; cell?.textLabel?.text = "123" return cell! &#125; func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123; print("click :\(indexPath.row)") &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(九)-正则表达式初探]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E4%B9%9D)-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344//// ViewController.swift// regularException//// Created by HMC on 16/8/10.// Copyright © 2016年 SKing. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let initString = "15225124020" //正则规则 //规则: /* ① [a-z] :表示匹配 a~z 的字母 例如: a ② [0-9]或者\\d :表示匹配 0~9 数字 ③ ^[a] :表示匹配以a字母开头的字串 ④ \\d&#123;2&#125; :表示匹配两个紧挨着的两个数字的字串 ⑤ [a-z]&#123;2,10&#125; :表示匹配字母有2~10字母相邻的字串 ⑥ //d[a-z]$ :表示匹配以字母为结尾的字串 ⑦ ^[^0-9] :表示匹配不能以数字开头的字串 */ let pattern = "^[1][34578]\\d&#123;9&#125;$" //正则表达式对象 guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else &#123; return &#125; //匹配返回的数组 let resultArray = regex.matchesInString(initString, options: [], range: NSRange(location: 0, length: initString.characters.count)) //遍历 for result in resultArray &#123; print((initString as NSString).substringWithRange(result.range)) &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(三)--函数封装--根据字符串创建对应的对象]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E4%B8%89)--%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85--%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536/** 根据字符串创建对应的对象 - parameter VCName: 类名称的字符串 */ func createVCObjectFromString(VCName:String) &#123; //获取命名空间 guard let nameSpace = NSBundle.mainBundle().infoDictionary!["CFBundleExecutable"] as? String else&#123; print("命名空间获取失败") return &#125; print("命名空间:\(nameSpace)") //获取 Class 的可选类型 guard let className = NSClassFromString(nameSpace + "." + VCName) else &#123; print("className获取失败") return &#125; print("className:\(className)") //转成控制器类型 guard let classType = className as? UIViewController.Type else&#123; print("类型转换失败") return &#125; print("控制器类型:\(classType)") //创建对应的类型的控制器 let VCObject = classType.init() print("最后创建的对象:\(VCObject)") &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift(十七)-使用-SQLite-操作数据库文件]]></title>
      <url>%2F2016%2F12%2F19%2FSwift(%E5%8D%81%E4%B8%83)-%E4%BD%BF%E7%94%A8-SQLite-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[一般在 APP 中,存储本地数据库文件我们大多使用 FMDB, 没有真正使用过 sqlite3的方式,操作数据库文件,下面我们一起探讨一下使用过程.首先,导入 sqlite3.0动态库, 其次还要创建一个桥接文件,在文件中导入:#import “sqlite3.h”,然后创建 Manager 文件,完成数据库文件的打开和 crud 操作;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//// SqliteManager.swift////// Created by HMC on 2016/10/25.// Copyright © 2016年 HMC. All rights reserved.//import UIKitclass SqliteManager: NSObject &#123; var db:OpaquePointer? = nil //单例 static let share = SqliteManager() override init() &#123; super.init() //打开数据库,如果不存在,创建 //是 自己电脑的名字 if sqlite3_open("/Users/hmc/Desktop/sqlite/DB.sqlite", &amp;db) == SQLITE_OK &#123; print("数据库打开成功") &#125;else&#123; print("数据库打开失败") &#125; &#125; &#125;extension SqliteManager &#123; /// 创建表 /// /// - returns: 是否成功 func createTable() -&gt; Bool &#123; let sql = "create table user (usid integer primary key autoincrement , username text ,userage integer default 20)" return sqlite3_exec(db, sql, nil, nil, nil) == SQLITE_OK &#125; /// 插入表 /// /// - parameter username: 用户名 /// - parameter userage: 用户年龄 /// /// - returns: 是否插入成功 func insert(username:String,userage:String) -&gt; Bool &#123; let sql = "insert into user (username , userage) values ('\(username)',\(userage))"// let sql1 = "insert into user (username) values ('\(username)')"// print(sql) return sqlite3_exec(db, sql, nil, nil, nil) == SQLITE_OK &#125; /// 删除表 /// /// - parameter ids: 删除的 id 的数组 /// /// - returns: 是否删除成功 func delete(ids:NSArray) -&gt; Bool &#123; for id in ids &#123; let sql = "delete from user where usid = \(id)" print(sql) return sqlite3_exec(db, sql, nil, nil, nil) == SQLITE_OK &#125; return false &#125; /// 查询表 最好使用 FMDB 因为已经对返回的结果做了处理,不需要对应该 index 的取字段,在这里的不做处理 /// /// - parameter ids: 查询的 id /// /// - returns: 是否查找成功 func select(id:NSString?) -&gt; Bool &#123; var sql = "" if (id != nil) &#123; let tmp : NSString = id! as NSString sql = "select * from user where 1 = 1 and usid = \(tmp)" &#125;else&#123; sql = "select * from user " &#125; print(sql) return sqlite3_exec(db, sql, nil, nil, nil) == SQLITE_OK &#125; /// 更新表 /// /// - parameter userage: 更新的字段 /// /// - returns: 是否更新成功 func update(userage:NSString) -&gt; Bool &#123; let sql = "update user set userage = \(userage)" print(sql) return sqlite3_exec(db, sql, nil, nil, nil) == SQLITE_OK &#125; /// 绑定参数插入 func insertbind() &#123; let sql = "insert into user (username,userage) values (?,?)" var ppStmt:OpaquePointer? = nil if sqlite3_prepare_v2(db, sql, -1, &amp;ppStmt,nil) == SQLITE_OK&#123; print("准备完成") //绑定 userage sqlite3_bind_int(ppStmt, 2, 30) //绑定 username sqlite3_bind_text(ppStmt, 1, "songjinwei", -1, unsafeBitCast(-1,to: sqlite3_destructor_type.self)) //sqlite3_step 执行语句 if sqlite3_step(ppStmt) == SQLITE_DONE &#123; print("执行完毕") //重置对象,方便下次进行操作 sqlite3_reset(ppStmt) //释放对象 sqlite3_finalize(ppStmt) &#125; &#125;else &#123; return &#125; &#125; func insertWithTransation() &#123; let start = CACurrentMediaTime() var status : Bool = true //不使用事务 会很慢 原因: 当我们使用 sqlite3_excute 的时候,会自动开启一个事务,执行 sql 后自动提交事务,这样在多次插入时候一开一合 很费时间,所以我们要手动打开事务和提交事务,插入完成 后统一提交.省时间 //不是 for i in 0..&lt;100000 &#123; status = status &amp;&amp; insert(username: "sjw \(i)", userage: "11") &#125; let end = CACurrentMediaTime() print( "不使用事务插入,插入十万条数据用时:\( end - start)") let start1 = CACurrentMediaTime() //开启事务 sqlite3_exec(db, "begin transaction", nil, nil, nil) for i in 0..&lt;100000 &#123; status = status &amp;&amp; insert(username: "sjw \(i)", userage: "11") &#125; if status&#123; //提交事务 sqlite3_exec(db, "commit transaction", nil, nil, nil) &#125;else&#123; //回滚事务 sqlite3_exec(db, "rollback transaction", nil, nil, nil) &#125; let end1 = CACurrentMediaTime() print( "使用事务插入,插入十万条数据用时:\( end1 - start1)") &#125;&#125; 注意:事务在数据库的真实操作中是非常非常重要的,关乎效率问题.看我测试截图你就明白: 调用1234567891011let status1: Bool = SqliteManager.share.createTable(); let status : Bool = SqliteManager.share.insert(username: "song", userage: "12"); // let status2: Bool = SqliteManager.share.delete(ids: array) // let status3: Bool = SqliteManager.share.select(id: "2") let status4 : Bool = SqliteManager.share.update(userage: "2") if status4 &amp;&amp; status1 &amp;&amp; status &#123; print("OK") &#125; SqliteManager.share.insertWithTransation() SQLiteManager代码在这 点我 明天补充 FMDB 的使用….晚安]]></content>
    </entry>

    
  
  
</search>
